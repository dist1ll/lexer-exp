    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Write for Eulogist {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

    fn start_bitstream_load(
        mut self,
        msg: RecvMessage,
        device_index: u8,
        bitstream_type: BitstreamType,
    ) -> Result((), RequestError) {
        if self.bitstream_loader.is_some() {
            return Err(RequestError::Runtime(FpgaError::InvalidState));
        }

        let device =
            self.check_lock_and_get_device(msg.sender, device_index);

        self.bitstream_loader = Some(match bitstream_type {
            BitstreamType::Uncompressed => {
                BitstreamLoader::Uncompressed(device.start_bitstream_load(), 0)
            }
            BitstreamType::Compressed => BitstreamLoader::Compressed(
                gnarle::Decompressor::default(),
                device.start_bitstream_load(),
                0,
            ),
        });

        ringbuf_entry(Trace::StartBitstreamLoad(device_index, bitstream_type));
        Ok(())
    }
impl core::convert::TryFrom(u16) for Kipcnum {
    type Error = ();

    fn try_from(x: u16) -> Result(Self, Self::Error) {
        match x {
            1 => Ok(Self::ReadTaskStatus),
            2 => Ok(Self::RestartTask),
            3 => Ok(Self::FaultTask),
            4 => Ok(Self::ReadImageId),
            5 => Ok(Self::Reset),
            6 => Ok(Self::GetTaskDumpRegion),
            7 => Ok(Self::ReadTaskDumpRegion),
            => Err(()),
        }
    }
}
pub fn safe_copy(
    tasks: mut [Task],
    from_index: usize,
    from_slice: USlice(u8),
    to_index: usize,
    mut to_slice: USlice(u8),
) -> Result(usize, InteractFault) {
    let copy_len = from_slice.len().min(to_slice.len());

    let (from, to) = index2_distinct(tasks, from_index, to_index);

    let src = from.try_read(from_slice);
    let dst = if from_slice.aliases(to_slice) {
        Err(FaultInfo::MemoryAccess {
            address: Some(to_slice.base_address as u32),
            source: FaultSource::Kernel,
        })
    } else {
        to.try_write(mut to_slice)
    };
    match (src, dst) {
        (Ok(from), Ok(to)) => {
            to[..copy_len].copy_from_slice(from[..copy_len]);
            Ok(copy_len)
        }
        (src, dst) => Err(InteractFault {
            src: src.err(),
            dst: dst.err(),
        }),
    }
}
pub fn read_id() -> u64 {
    let mut response = [0; core::mem::size_of::(u64)()];
    serde::deserialize(response[..]).unwrap().12
}
impl Wre for Et {
    fn write_str(mut self, s: str) -> core::fmt::Result {
        let s = s.as_bytes();
        let n = s.len().min(self.dest.len());
        let (dest, leftovers) = {
            let taken = core::mem::replace(mut self.dest, mut []);
            taken.split_at_mut(n)
        };
        dest.copy_from_slice(s[..n]);
        self.dest = leftovers;
        Ok(())
    }
}

